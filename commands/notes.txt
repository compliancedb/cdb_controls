Loan-calculator
 - main.yml
 - production.yml
 - approval.yml


Used in loan-calculator?
YES----------------------------------------Makefile---------Tests------------------------------------
FROM                    TO                 Target    docs   ALL-EVS   ONLY-REQ-EVS   MISSING-REQ-EVS
put_pipeline            declare_pipeline   yes       wip    yes       N/A            no
create_approval         log_approval       wip       wip    yes       no             no
control_junit           log_test           yes       wip    yes       no             no
put_artifact_image      log_artifact       yes       wip    yes       no             yes
create_deployment       log_deployment     yes       wip    yes       no             no
put_evidence            log_evidence       yes       wip    yes       no             no
nothing                 control_deployment no        wip    no        no             no
control_latest_release  retire
Not-------------------------------------------------------------------------------------------
control_junit           log_test_results   no        no     no        no             no
control_bitbucket_pr    log_bitbucket_pr   no        no     no        no             no
create_release          request_approval   no        no     no        no             no



log_approval:
Has this
		--env MERKELY_SRC_REPO_ROOT=${MERKELY_SRC_REPO_ROOT} \
		--volume ${PWD}:/src \
If MERKELY_SRC_REPO_ROOT is not /src/ then the volume-mount will be wrong...
If we want the Makefile target to be reusable 'as-is' we could drop
MERKELY_SRC_REPO_ROOT (which defaults to /src) and require the
volume-mount to always be /src ?




Command Names:?
---------------
log_evidence   ===> log_X_evidence ?
     The name feels very generic?
     I presume the evidence_type env-var must match Merkelypipe.json "template"
     Could we find a name based on that?

log_test       ===> log_junit_xml_evidence ?
     Again the name feels very generic.
     Also has an evidence_type env-var.

log_deployment ===> log_image_registry_push
     Words: deployment is something different to me, eg of an image to staging so its _runnable_ somewhere

log_approval   ===> log_release_approval
     Again the name feels very generic.
     Will we want approval of different things/steps?
     What exactly is this approving?

nothing        ===> control_deployment ==> ????
     Feels too generic ????



In main.yml
- name: Build and push Docker image         - name: Build and push Docker image to dockerhub
- name: Get tagged Docker image name        - name: ?????
- name: Declare Merkely pipeline            - name: Merkely: Declare Pipeline
- name: Log Docker image to Merkely         - name: Merkely: Log Event: Docker image existence.
- name: Log image deployment to Merkely     - name: Merkely: Log Event: Docker image pushed to dockerhub registry.
- name: Run tests                           - name: Run tests
- name: Log test results to Merkely         - name: Merkely: Log Evidence: JUnit xml test summary.
- name: Log coverage evidence to Merkely    - name: Merkely: Log Evidence: JUnit coverage summary.



Is there a difference (compliance wise) between the JUnit xml test summary
and the JUnit coverage summary?

merkely/change repo still need to create Merkelypipe.json file(s) in root dir.


Parked...
=========

builders could be implemented using __init_subclass__

Put declare_merkely_pipeline go at very start of main.yml
Even before building and pushing the image?

main.yml has this (at the end)
source tmp/coverage/unit/htmlcov/test_coverage.txt
source tmp/coverage/unit/htmlcov/test_cases.txt
These would be better as .sh files?

CommandError should be named ChangeError.
And moved out of commands/ module to break cyclic dependencies

tests/unit/test_m_defaulted_env_var.py's 1st line is this:
from commands import CommandError # avoid cyclic dependency
Look into solving this cyclic-dependency properly.

Some tests are producing output when they run.
eg tests/unit/test_m_log_approval.py

Check when using pathed-filename to get sha for that
cdb and merkely behave the same regarding only showing
the basename of the pathed-filename.

Create a source/ dir and move everything into it.

load_json() should be in context to allow easy stubbing.

Context() should be named Externals.

Context() should have keyword args?

Provide Log in External, get Commands to return (method,url,payload)
and do http as separate step.

Could look for *unused* env-vars starting with MERKELY_
and report warnings...

Command could start by printing list of environment variables and their type?

Print 'success' at end of successful command run?

Look into how Python recommended style for abstract-base-classes.

Mock fingerprinters code in tests/utils could be collapsed using
multiple inheritance.

Commands should return the triple(method,url,payload)
and a 2nd step is to do the http get/post/put.
This would simplify the tests by not needing the
dry_run() unless they call main.

As a general principle, for anything in a docstring,
consider whether it should be part of the living documentation.

Once living documentation is in place, warning/error messages can
include targeted urls.

