

Currently:

NAME                    Type       Description

MERKELY_COMMAND         required    The Merkely command to execute.
MERKELY_FINGERPRINT     required    ...
MERKELY_EVIDENCE_TYPE   required    The evidence type.
MERKELY_IS_COMPLIANT    required    Whether this artifact is considered compliant from you build process.
MERKELY_DESCRIPTION     optional    The description for the evidence.
MERKELY_CI_BUILD_URL    required    Link to the build information.
MERKELY_API_TOKEN       required    Your API token for Merkely.
MERKELY_HOST            defaulted   The host name for Merkely. The default is https://app.compliancedb.com

Proposal: All env-vars must be a string with a protocol prefix.

NAME                    Required?   Protocols                         Notes (can be keyed on the clicked protocol?)

MERKELY_COMMAND         yes         string://log_evidence
MERKELY_FINGERPRINT     yes         docker:// file:// sha256://       The name and tag of your docker image.
MERKELY_EVIDENCE_TYPE   yes         string://                         A Merkelypipe.json "template" entry.
MERKELY_IS_COMPLIANT    yes         bool://                           bool://TRUE or bool://FALSE
MERKELY_DESCRIPTION     no          string://
MERKELY_CI_BUILD        yes         url://
MERKELY_API_TOKEN       yes         string:// ??
MERKELY_HOST            no          url://                            defaults to https://app.merkely.com
Plus...for other commands...
MERKELY_USER_DATA       no          file:// json://


Note: Not sure about which of these...?
MERKELY_CI_BUILD_URL="url://${...}"
MERKELY_CI_BUILD="url://${...}"
Could different kinds of url.
eg curled_url:// which curls the url to verify it exists


THOUGHTS...
The living-documentation of merkely/change doesn't feel right yet.
The [docker run...] strings we are generating feel too fiddly.
Not "alive enough"
Not extensible enough.
Not at the right level of abstraction...
Consider, in the docs reference section, the [docker run...] example will
have several tabs, eg, Github-Actions, CircleCI, etc, etc
I think our DescribeCommand sphinx extension should scrape ACTUAL .yml files.
Then it would be alive.
  o) We would scrape from ACTUAL repos, eg the loan-calculator
  o) These repos would be deliberately kept OFF the merkely github org so they have client-centric names.
  o) The repo's initial .yml file should be reference.yml which does not use a makefile.

Eg  For github Actions, log_artifact would  scrape from reference.yml which would be this:

    - name: Publish docker image information to Merkely
      run: |
        export SHA7=$(git log -1 --pretty=%h)
        export MY_IMAGE_AND_TAG=acme/loan-calculator:sha-${SHA7}
        export MY_GIT_URL=https://github.com/acme/loan-calculator/commit/${GITHUB_SHA}
        export MY_CI_URL=https://github.com/acme/loan-calculator/actions/runs/${GITHUB_RUN_ID}

	    docker run \
			--env MERKELY_COMMAND=log_artifact \
			--env MERKELY_FINGERPRINT="docker://${MY_IMAGE_AND_TAG}" \
			--env MERKELY_GIT_URL="url://${MY_GIT_URL}" \
			--env MERKELY_CI_URL="url://${MY_CI_URL} \
			--env MERKELY_IS_COMPLIANT=bool://TRUE \
			\
			--env MERKELY_GIT_COMMIT="string://${GITHUB_SHA}" \
			--env MERKELY_CI_NUMBER="integer://${GITHUB_RUN_ID}" \
			--env MERKELY_API_TOKEN="string://${{ secrets.MERKELY_API_TOKEN }}" \
			--rm \
			--volume=/var/run/docker.sock:/var/run/docker.sock \
			--volume ${PWD}/${MERKELYPIPE}:/Merkelypipe.json \
			merkely/change


Notes:

o) The org-name and repo-name are surely available as env-vars exposed by Github-Action?

o) We would add a prominent note on the html reference page saying that
   this is the "reference" version, which can easily be 'pushed down'
   into a bash file, or a makefile, held in the repo, with the words
   'bash file' and 'makefile' being http-links to the actual files
   in the scraped repo.

o) This means declare_pipeline has its own separate entry too.
   Which feels right since this is a reference.

o) I have imagined dropping the word ARTIFACT from the ENV_VAR names.

o) It feels like MERKELY_FINGERPRINT now wants to be MERKELY_ARTIFACT
   The command is the verb action.
   Everything else names a thing, a noun.









Priorities                                    Tests
FROM                   TO                     ALL-EVS   ONLY-REQ-EVS   MISSING-REQ-EVS
put_artifact_image     log_artifact           yes       no             yes
control_junit          log_test_results       no        no             no
control_bitbucket_pr   log_bitbucket_pr       no        no             no
create_deployment      log_deployment         yes       no             no
create_release         log_approval           no        no             no
                       log_evidence           yes       no             no
                       declare_pipeline       yes       N/A            no


Check when using pathed-filename to get sha for that
cdb and merkely behave the same regarding only showing
the basename of the pathed-filename.

Should create a source/ dir and move everything into it.

load_json() should be in context to allow easy stubbing.

Context() ctor should have keyword args.

Could look for unused env-vars starting with MERKELY_
and report warnings...

Command could start by printing list of environment variables and their type.

Print 'success' at end of successful command run?

Look into how Python recommended style for abstract-base-classes.

Mock fingerprinters code in tests/utils could be collapsed using
multiple inheritance.

Commands should return the triple(method,url,payload)
and a 2nd step is to do the http get/post/put.
This would simplify the tests by not needing the
dry_run() everywhere.

As a general principle, for anything in a docstring,
consider whether it should be part of the living documentation.

Once living documentation is in place, warning/error messages can
include targeted urls.

properties/methods that exist in abstract-base-classes only to be
overridden are marked # pragma: no cover
Maybe add programmer-tests for these and remove the pragmas.